// We need to import a couple of ANLTR modules
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;

public class Calculator {

	// The main function just instantiates our calculator and runs it.
	public static void main(String args[]) throws Exception {

		try {
			Calculator c = new Calculator();
			c.run();
		}
		catch (Exception e)
		{
			e.printStackTrace ();
		}
	}


	// The run function will interact with us through the console
	// asking for arithmetic expressions and returing their value
	public void run() throws Exception {

		// We instantiate an evaluator of arithmetic expressions
		// stored in an visitor-based AST
		Evaluator evaluator = new Evaluator();

		while (true) {
			// Read an expression from the console
			System.out.print("Enter an arithmetic expression: ");
			String input = System.console().readLine();

			// Build the parser for the content of the input in several steps

			// Translate the input string into stream of characters
			CharStream inputStream = CharStreams.fromString(input);

			// Create a lexer for the CharStream
			CalculatorLexer lex = new CalculatorLexer(inputStream);

			// Use the lexer to generate the token stream
			CommonTokenStream tokens = new CommonTokenStream(lex);

			// Create a parser for the given token stream
			CalculatorParser parser = new CalculatorParser(tokens);

			// Use the evaluator to evaluate the AST as constructed
			// by the parser and starting wth non-terminal "start"
			Double result = evaluator.visit(parser.start());

			// print the result of parsing the input
			System.out.println(result);

		}
	}

	// We define here an evaluation function as extension of the base visitor generated by ANTLR
	// The evaluation function is implicitly defined as a visitor of parse trees
	// The main idea is that, for each node class C in the tree, we need to implement a function
	// that returns the result of evaluating trees that have roots of class C.
	// The returning value in our case is Double.

	public class Evaluator extends CalculatorBaseVisitor<Double> {

		@Override
		public Double visitStart(CalculatorParser.StartContext ctx) {
			return this.visit(ctx.expr());
		}

		@Override
		public Double visitTimesExpr(CalculatorParser.TimesExprContext ctx) {
			// recursively visit/evaluate the two operands
			// and return their product
			return (visit(ctx.lhs) * visit(ctx.rhs));
		}

		@Override
		public Double visitDivExpr(CalculatorParser.DivExprContext ctx) {
			// recursively visit/evaluate the two operands
			// and return their division
			return (visit(ctx.lhs) / visit(ctx.rhs));
		}

		@Override
		public Double visitPlusExpr(CalculatorParser.PlusExprContext ctx) {
			// recursively visit/evaluate the two operands
			// and return their sum
			return (visit(ctx.lhs) + visit(ctx.rhs));
		}


		@Override
		public Double visitMinusExpr(CalculatorParser.MinusExprContext ctx) {
			// recursively visit/evaluate the two operands
			// and return their substraction
			return (visit(ctx.lhs) - visit(ctx.rhs));
		}

		@Override
		public Double visitPowExpr(CalculatorParser.PowExprContext ctx) {
			// recursively visit/evaluate the two operands
			// and return their exponentiation
			return (Math.pow(visit(ctx.lhs),visit(ctx.rhs)));
		}

		@Override
		public Double visitNumExpr(CalculatorParser.NumExprContext ctx) {
			// extract the double value of the number (as a string)
			return Double.valueOf(ctx.n.getText());
		}

		@Override
		public Double visitUPlusExpr(CalculatorParser.UPlusExprContext ctx) {
			// extract the double value of the number (as a string)
			return visit(ctx.e);
		}

		@Override
		public Double visitUMinusExpr(CalculatorParser.UMinusExprContext ctx) {
			// extract the double value of the number (as a string)
			return - visit(ctx.e);
		}

		@Override
		public Double visitNestedExpr(CalculatorParser.NestedExprContext ctx) {
			// evaluate the nested expression and return its value
			return this.visit(ctx.expr());
		}
	}


}
